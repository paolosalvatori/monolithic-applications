# Monolithic Applications

A monolithic application refers to a software application that is built as a single, self-contained unit with all its components tightly integrated together. In a monolithic architecture, all the modules and components of the application are combined into a single executable file or codebase, and they all run within a single process. This means that all the features and functionalities of the application are packaged and deployed together, and any changes or updates to the application require modifying and redeploying the entire monolithic application.

Examples of typical monolithic applications in different programming languages that run on Linux and Windows are:

- .NET Monolithic Application: An example of a monolithic application in .NET could be a traditional ASP.NET Web Forms application written in C# using the [.NET framework](https://learn.microsoft.com/en-us/dotnet/framework/get-started/) where the entire application logic, including the UI, business logic, and data access, runs in [Internet Information Services (IIS)](https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/iis/iis-welcome) or is bundled into a single executable file. All the components of the application run within a single process, for example an application pool in IIS or a Windows service, and are tightly coupled together.
- WCF service: Another example of monolithic application is a service-oriented application built using the [Windows Communication Foundation(WCF)](https://learn.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf) framework using the full .NET framework. WCF is supported in the [.NET framework](https://learn.microsoft.com/en-us/dotnet/framework/get-started/), but not in [.NET 5+](https://learn.microsoft.com/en-us/dotnet/standard/glossary#net-5-and-later-versions). The .NET Framework is a [.NET version](https://learn.microsoft.com/en-us/dotnet/standard/glossary#implementation-of-net) that runs only on Windows, while [.NET 5+](https://learn.microsoft.com/en-us/dotnet/standard/glossary#net-5-and-later-versions) ia a cross-platform, high-performance, open-source implementation of .NET. Also referred to as .NET 5+.
- Java Monolithic Application: An example of a monolithic application in Java could be an enterprise [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) application built using the [Java Enterprise Edition (Java EE)](https://www.oracle.com/java/technologies/java-ee-glance.html) platform, where the entire application, including the web tier, business logic, and data access, is packaged into a single WAR (Web Archive) file or EAR (Enterprise Archive) file and deployed to a Java application server, such as [Apache Tomcat](https://tomcat.apache.org/) or [IBM WebSphere](https://www.ibm.com/products/websphere-application-server).
- Windows Monolithic Application: An example of a monolithic application that runs on Windows could be a traditional two-tier or three-tier Windows Forms or WPF (Windows Presentation Foundation) desktop application, where all the UI, business logic, and data access are combined into a single executable file and run within the same process.
- Other examples of monolithic applications in different programming languages and platforms could include a [single-page application (SPA)](https://en.wikipedia.org/wiki/Single-page_application) built using a monolithic [JavaScript](https://en.wikipedia.org/wiki/JavaScript) framework like [AngularJS](https://angular.io/) or [React](https://react.dev/), a Content Management System (CMS)) application where all the components are bundled together, or an ERP (Enterprise Resource Planning) application where all the modules are tightly integrated into a single executable or codebase.

A typical monolithic application uses a layered design, with separate layers for UI, application logic, and data access.

As a monolithic application grows, it can start suffering from the following problems:

- Individual components and subsystems cannot be scaled independently from one another because they are tightly coupled.
- It is hard to maintain a single codebase because of tight coupling and hidden dependencies between the libraries used by the monolithic application.
- Testing becomes harder, increasing the likelihood of introducing vulnerabilities.
- Software components and libraries need to be written using the same programming language.

These problems can become a challenge and obstacle to future growth and stability. Teams could be wary of making changes, especially if the original developers are no longer working on the project and design documents are sparse or outdated.

In the early phases of development, monoliths tend to be easier to create because there is a single shared codebase to test and maintain. Still, as the application grows in complexity, they become progressively harder to build, debug, deploy, monitor, and support. At some point, the problems can outweigh the benefits. This is when it can make sense to migrate the application to a microservices architecture. Unlike monoliths, microservices are typically decentralized, loosely coupled units of execution. A [microservice-based architecture](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices) provides the following advantages over a monolithic application:

- Services can evolve independently based on user needs.
- Services can be built using different teams' different technology stacks and programming languages.
- Services can scale independently to keep up with the traffic conditions.
- Over time, development cycles become faster as features can be released to market quicker.
- Services are isolated and are more tolerant of failure.
- A single service that fails will not bring down the entire application.
- Testing becomes more coherent and consistent using behavior-driven development.

Migrating a monolithic application to a microservice-based architecture requires significant time and investment. For this reason, when bringing a monolithic application to Azure, a customer usually starts with a lift-and-shift approach where the monolithic application is hosted in set of Windows or Linux virtual machines, while the database in another virtual machine. The next step in the cloud journey typically consists in containerizing and hosting a monolithic application in compute platform such as [Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes), [Azure Container Apps (ACA)](https://learn.microsoft.com/en-us/azure/container-apps/overview), [Azure Container Instances (ACI)](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-overview), or [Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview) and the database in an Azure fully-managed database like [Azure SQL Database](https://learn.microsoft.com/en-us/azure/azure-sql/database/sql-database-paas-overview?view=azuresql) or [Azure Database for PostgreSQL](https://learn.microsoft.com/en-us/azure/postgresql/) that provides advantages like automatic patching or backups.

The final step is refactoring the application using a microservice-based approach and hosting the application in [Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes) or [Azure Container Apps (ACA)]. If not already present in the organization, this step requires to acquire specific skills in many areas, which include not only Kubernetes, but also related technologies and processes such as [GitOps](https://www.weave.works/technologies/gitops/) and [DevOps](https://en.wikipedia.org/wiki/DevOps).

## Azure Services

The following table compares hosting a monolithic application on different hosting platforms on Azure.

| | [Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes) | [Azure Container Apps (ACA)](https://learn.microsoft.com/en-us/azure/container-apps/overview) | [Azure Container Instances (ACI)](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-overview) | [Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview) |
|-|-|-|-|-|
| Definition | [Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes) provides a fully managed Kubernetes option in Azure. It supports direct access to the Kubernetes API and runs any Kubernetes workload. The full cluster resides in your subscription, with the cluster configurations and operations within your control and responsibility. Teams looking for a fully managed version of Kubernetes in Azure, Azure Kubernetes Service is an ideal option. AKS supports running Windows containers on Windows Server node pools | [Azure Container Apps (ACA)](https://learn.microsoft.com/en-us/azure/container-apps/overview) enables you to run and operate microservice-based applications or containerized monolithic applications. It supports Kubernetes-style apps and microservices with features like [service discovery](https://learn.microsoft.com/en-us/azure/container-apps/connect-apps), [traffic splitting](https://learn.microsoft.com/en-us/azure/container-apps/revisions) or [Kubernetes Event-Driven Autoscaling (KEDA)](https://keda.sh/), but it doesn't provide direct access to the underlying Kubernetes APIs. [Azure Container Apps (ACA)](https://learn.microsoft.com/en-us/azure/container-apps/overview) does not support [Windows containers](https://learn.microsoft.com/en-us/virtualization/windowscontainers/about/) | [Azure Container Instances (ACI)](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-overview) offers the fastest and simplest way to run a container in Azure, without having to manage any virtual machines and without having to adopt a higher-level service. Azure Container Instances is a great solution for any scenario that can operate in isolated containers, including monolithic applications, task automation, and build jobs. For more information, see [ACI Considerations](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-overview#considerations). | [Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview) is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends. You can develop in your favorite language, be it .NET, .NET Core, Java, Ruby, Node.js, PHP, or Python. Azure App Service does not require containerizing a web application.  |
| Scenarios | [Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes) is the recommended hosting platform when you need full container orchestration, including service discovery across multiple containers, automatic scaling, load balancing, and coordinated application upgrades for both Linux and Windows monolithic applications. | [Azure Container Apps (ACA)](https://learn.microsoft.com/en-us/azure/container-apps/overview) is an ideal alternative to Azure Kubernetes Service (AKS) for hosting Linux-based monolithic applications when the development and operations teams don't have the necessary expertise to deploy, operate, and maintain a full-fledged Kubernetes project. | [Azure Container Instances (ACI)] is a great solution for any scenario that can operate in isolated containers, including Linux or Windows monolithic applications that don't to need to dynamically scale out or scale in, task automation, and build jobs. | [Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview) is an ideal solution for hosting a web application developed with the .NET framework or Java, while it's not ideal for hosting a monolithic application that does not expose a web interface, for example a backend application running in a Windows service. |

